"""
This type stub file was generated by pyright.
"""

"""
Term business object and repository.

Terms are converted to and from lute.models.term.Term objects to save
them in the database.
"""
class Term:
    """
    Term business object.  All class members are primitives.
    """
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def language(self): # -> Language | None:
        "Use or get the language."
        ...
    
    @language.setter
    def language(self, lang): # -> None:
        ...
    


class TermReference:
    "Where a Term has been used in books."
    def __init__(self, bookid, txid, pgnum, title, sentence=...) -> None:
        ...
    


class Repository:
    """
    Maps Term BO to and from lute.model.Term.
    """
    def __init__(self, _db) -> None:
        ...
    
    def load(self, term_id): # -> Term:
        "Loads a Term business object for the DBTerm with the id."
        ...
    
    def find(self, langid, text): # -> Term | None:
        """
        Return a Term business object for the DBTerm with the langid and text.
        If no match, return None.
        """
        ...
    
    def find_or_new(self, langid, text): # -> Term:
        """
        Return a Term business object for the DBTerm with the langid and text.
        If no match, return a new term with the text and language.

        Note that this does a search by the **tokenized version**
        of the text; i.e., first the text argument is converted into
        a "search specification" (spec) using the language with the given id.
        The db search is then done using this spec.  In most cases, this
        # will suffice.

        # In some cases, though, it may cause errors.  The parsing here is done
        # without a fuller context, which in some language parsers can result
        # in different results.  For example, the Japanese "集めれ" string can
        # can be parsed with mecab to return one unit ("集めれ") or two ("集め/れ"),
        # depending on context.

        # So what does this mean?  It means that any context-less searches
        # for terms that have ambiguous parsing results will, themselves,
        # also be ambiguous.  This impacts csv imports and term form usage.

        # For regular (reading screen) usage, it probably doesn't matter.
        # The terms in the reading screen are all created when the page is
        # opened, and so have ids assigned.  With that, terms are not
        # searched by text match, they are only searched by id.

        ## TODO verify_identity_map_comment:
        If it's new, don't add to the identity map ... it's not saved yet,
        and so if we search for it again we should hit the db again.

        # the above statement about the identity map was old code, and I'm not
        # sure it's a valid statement/condition.
        """
        ...
    
    def find_matches(self, langid, text, max_results=...): # -> list:
        """
        Return array of Term business objects for the DBTerms
        with the same langid, matching the text.
        If no match, return [].
        """
        ...
    
    def get_term_tags(self): # -> list:
        "Get all available term tags, helper method."
        ...
    
    def add(self, term): # -> Term | None:
        """
        Add a term to be saved to the db session.
        Returns DB Term for tests and verification only,
        clients should not change it.
        """
        ...
    
    def delete(self, term): # -> None:
        """
        Add term to be deleted to session.
        """
        ...
    
    def commit(self): # -> None:
        """
        Commit everything.
        """
        ...
    
    def find_references(self, term): # -> dict[str, list]:
        """
        Return references of term, children, and parents.
        """
        ...
    


