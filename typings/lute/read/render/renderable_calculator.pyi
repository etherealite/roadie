"""
This type stub file was generated by pyright.
"""

from lute.models.language import Language

"""
Calculating what items should be rendered in the browser.
"""
class RenderableCalculator:
    """
    Calculating what TextTokens and Terms should be rendered.

    Suppose we had the following TextTokens A-I, with spaces between:

     A B C D E F G H I

    Then suppose we had the following Terms:
      "B C"       (term J)
      "E F G H I" (K)
      "F G"       (L)
      "C D E"     (M)

    Stacking these:

     A B C D E F G H I

      "B C"              (term J)
            "E F G H I"  (term K)
              "F G"      (term L)
        "C D E"          (term M)

    We can say:

    - term J "contains" TextTokens B and C, so B and C should not be rendered.
    - K contains tokens E-I, and also L, so none of those should be rendered.
    - M is _not_ contained by anything else, so it should be rendered.
    """
    def main(self, language, words, texttokens): # -> list:
        """
        Main entrypoint.

        Given a language and some terms and texttokens,
        return the RenderableCandidates to be rendered.
        """
        ...
    
    @staticmethod
    def get_renderable(lang, words, texttokens): # -> list:
        "Convenience method, calls main."
        ...
    


class RenderableCandidate:
    """
    An item that may or may not be rendered on the browser.

    Given some Terms contained in a text, the RenderableCalculator
    creates RenderableCandidates for each Term in the text, as well as
    the original text tokens.
    """
    class_id = ...
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def term_id(self) -> int:
        ...
    
    @property
    def order_end(self) -> int:
        ...
    
    def make_text_item(self, p_num: int, se_id: int, lang: Language): # -> TextItem:
        """
        Create a TextItem for final rendering.
        """
        ...
    


class TokenLocator:
    """
    Helper class for finding tokens and positions in a subject string.

    Finds a given token (word) in a sentence, ignoring case, returning
    the actual word in the sentence (its original case), and its index
    or indices.

    For example, given:

      - $subject "/this/ /CAT/ /is/ /big/"
      - $find_patt = "/cat/"

    (where "/" is the zero-width space to indicate word boundaries)

    this method would return [ { 'term': "CAT", 'index': 2 } ]
      - the token "cat" is actually "CAT" (uppercase) in the sentence
      - it's at index = 2

    Note that the language of the string must also be provided, because
    some languages (Turkish!) have unusual case requirements.

    See the test cases for more examples.
    """
    def __init__(self, language, subject) -> None:
        ...
    
    def locate_string(self, s): # -> list[dict[str, Any]]:
        """
        Find the string s in the subject self.subject.
        """
        ...
    
    def get_count_before(self, string, pos):
        """
        Count of tokens found in string before position pos.
        """
        ...
    
    def preg_match_capture(self, find_lc, subject): # -> list[list]:
        """
        Return the matched text and their start positions in the subject.

        E.g. search for r'cat' in "there is a CAT and a Cat" returns:
        [['CAT', 11], ['Cat', 21]]
        """
        ...
    
    @staticmethod
    def make_string(t): # -> str:
        """
        Append zero-width string to string to simplify/standardize searches.
        """
        ...
    


class TextItem:
    """
    Unit to be rendered.

    Data structure for template read/textitem.html

    Some elements are lazy loaded, because they're only needed in
    certain situations.
    """
    def __init__(self, term=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def term(self):
        ...
    
    @property
    def wo_id(self): # -> None:
        "The term id is the wo_id."
        ...
    
    @term.setter
    def term(self, t): # -> None:
        ...
    
    @property
    def show_tooltip(self): # -> bool:
        """
        Show the tooltip if there is anything to show.
        Lazy loaded as needed.
        """
        ...
    
    @property
    def flash_message(self): # -> str | None:
        """
        Return flash message if anything present.
        Lazy loaded as needed.
        """
        ...
    
    @property
    def html_display_text(self): # -> str:
        """
        Content to be rendered to browser.
        """
        ...
    
    @property
    def span_id(self): # -> str:
        """
        Each span gets a unique id.
        Arbitrary format: ID-{order}-{tokencount}.

        This *might* not be necessary ... I don't think IDs are used anywhere.
        """
        ...
    
    @property
    def status_class(self): # -> str:
        "Status class to apply."
        ...
    
    @property
    def html_class_string(self): # -> str:
        """
        Create class string for TextItem.
        """
        ...
    


